/*****************************
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
*****************************/

class Solution {
public:
    int climbStairs(int n) {
          int n_1 = 1;
        int n_2 = 0;
        int tmp;
        for(int i=1; i<=n; i++){
        tmp = n_1+n_2;
        n_2 = n_1;
        n_1 = tmp;
    }
    return tmp;
    }
};

/*****************************
动态规划的程序每次看起来都是非常简洁的，但是学会用动态规划的思想去解决问题是很重要的。 
都有什么问题能用动态规划解决呢？ 
1、具有最优子结构，如果最优解中包含了 子问题的最优解，则该问题就具有最优子结构，所以解决问题的
第一步就是对最优子结构进行描述。 
2、子问题不独立，也就是子问题包含公共的子子问题，动态规划可以保存子子问题的结果，从而避免多次求
解，将计算复杂度从指数级降低到线性级。 
在这个爬楼梯的问题中，最重要的是能够描述最优子结构，这个也是我在解题过程中很犯难的过程，知道借
鉴的大牛的答案，才茅塞顿开。我看到的第一个解决方案是“找规律”，发现an=an-1+an-2（原谅我不会打
下角标，自行补脑啊，高中题目里面天天见的那种），我赶紧验证了一下，令n表示台阶个数，coun表示方
案个数。发现n=1,coun=1;n=2;coun=2;n=3,coun=3;n=4,coun=5;n=5,coun=8;n=6,coun=13.规律
是正确的，但是总是感觉牵强了点。知道我看到一个让我心服口服的答案。

是这样的，n为1，2的时候很好验证，当n>=3的时候，有两种攀爬方案（即最优子结构的描述）：一种是攀
登到第n-2层台阶，之后一下迈两个台阶到达n；另外一种是攀登到n-1层台阶，然后走一步到达台阶n。所
以就是an=an-1+an-2。醍醐灌顶啊，有没有感觉整个人都清爽了很多。所以问题的关键就是找到最优子结
构，并进行描述，之后写代码就是so easy啦.
*****************************/
